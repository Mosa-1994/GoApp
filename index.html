<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halte</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
    <link rel="apple-touch-icon" href="assets/halte-icon.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="theme-color" content="#0a0a0b">
</head>
<body>
    <div class="container">
        <header>
            <h1>H<svg class="logo-icon" viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M20 4L6 36h6l2-6h12l2 6h6L20 4z"/><path d="M12 26h16"/></svg>LTE</h1>
            <button class="stop-selector-btn" onclick="openStopSelector()" aria-label="Halte wijzigen">
                <span id="currentStopName">De Meern, Veldhuizen</span>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M6 9l6 6 6-6"/>
                </svg>
            </button>
        </header>

        <div class="status-bar">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Verbonden</span>
            <button class="refresh-btn" id="refreshBtn" onclick="handleRefreshClick()" aria-label="Ververs">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
                </svg>
            </button>
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Wissel thema">
                <svg class="theme-icon-sun" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"/>
                    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                </svg>
                <svg class="theme-icon-moon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
                </svg>
            </button>
        </div>

        <div id="content">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Laden...</p>
            </div>
        </div>

        <footer>
            <a href="https://drgl.nl" target="_blank">drgl.nl</a>
        </footer>
    </div>

    <!-- Stop selector modal -->
    <div class="stop-modal" id="stopModal" aria-hidden="true">
        <div class="stop-sheet" role="dialog" aria-modal="true" aria-label="Halte kiezen">
            <div class="stop-header">
                <div class="stop-title">Halte kiezen</div>
                <button class="stop-close" onclick="closeStopSelector()" aria-label="Sluiten">✕</button>
            </div>
            <div class="stop-search">
                <input type="text" id="stopSearchInput" placeholder="Zoek halte of station..." autocomplete="off">
                <div id="searchResults" class="search-results"></div>
            </div>
            <div class="favorites-section">
                <div class="favorites-title">Favorieten</div>
                <div id="favoritesList" class="favorites-list">
                    <!-- Favorites will be rendered here -->
                </div>
            </div>
        </div>
    </div>

        <div class="map-modal" id="mapModal" aria-hidden="true">
        <div class="map-sheet" role="dialog" aria-modal="true" aria-label="Live positie">
            <div class="map-header">
                <div class="map-title">
                    Live positie
                    <span class="map-badge" id="mapStopsBadge" hidden></span>
                </div>
                <button class="map-close" onclick="closeMapModal()" aria-label="Sluit kaart">✕</button>
            </div>
            <div id="liveMap" class="map-canvas"></div>
            <div id="mapMeta" class="map-meta">Laden...</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
        // Theme toggle
        function updateThemeColor(theme) {
            const themeColor = theme === 'light' ? '#f1f5f9' : '#0a0a0b';
            const metaTheme = document.querySelector('meta[name="theme-color"]');
            if (metaTheme) {
                metaTheme.setAttribute('content', themeColor);
            }
        }

        function initTheme() {
            try {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    document.documentElement.setAttribute('data-theme', savedTheme);
                    updateThemeColor(savedTheme);
                } else {
                    // Set default theme explicitly
                    document.documentElement.setAttribute('data-theme', 'dark');
                    updateThemeColor('dark');
                }
            } catch (e) {
                // localStorage not available, use dark as default
                document.documentElement.setAttribute('data-theme', 'dark');
                updateThemeColor('dark');
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            updateThemeColor(newTheme);
            try {
                localStorage.setItem('theme', newTheme);
            } catch (e) {
                // localStorage not available, theme will reset on reload
            }
        }

        // Initialize theme on load
        initTheme();

        // ===== FAVORITES SYSTEM =====
        const FAVORITES_KEY = 'halte-favorites';
        const SELECTED_STOP_KEY = 'halte-selected-stop';

        // Default stops
        const DEFAULT_STOPS = [
            {
                id: 'NL:S:51200123',
                name: 'De Meern, Veldhuizen',
                type: 'bus',
                lat: 52.0839993,
                lon: 5.0132954
            },
            {
                id: 'NL:S:vtn',
                name: 'Station Vleuten',
                type: 'train',
                lat: 52.1053,
                lon: 5.0075
            }
        ];

        // Current selected stop
        let currentStop = null;
        let searchTimeout = null;

        function loadFavorites() {
            try {
                const stored = localStorage.getItem(FAVORITES_KEY);
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Could not load favorites:', e);
            }
            return [...DEFAULT_STOPS];
        }

        function saveFavorites(favorites) {
            try {
                localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
            } catch (e) {
                console.warn('Could not save favorites:', e);
            }
        }

        function loadSelectedStop() {
            try {
                const stored = localStorage.getItem(SELECTED_STOP_KEY);
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Could not load selected stop:', e);
            }
            // Default to first favorite (bus stop)
            const favorites = loadFavorites();
            return favorites[0] || DEFAULT_STOPS[0];
        }

        function saveSelectedStop(stop) {
            try {
                localStorage.setItem(SELECTED_STOP_KEY, JSON.stringify(stop));
            } catch (e) {
                console.warn('Could not save selected stop:', e);
            }
        }

        function initializeStops() {
            currentStop = loadSelectedStop();
            updateCurrentStopDisplay();
        }

        function updateCurrentStopDisplay() {
            const nameEl = document.getElementById('currentStopName');
            if (nameEl && currentStop) {
                nameEl.textContent = currentStop.name;
            }
        }

        function selectStop(stop) {
            currentStop = stop;
            saveSelectedStop(stop);
            updateCurrentStopDisplay();
            closeStopSelector();
            loadDepartures();
        }

        function addFavorite(stop) {
            const favorites = loadFavorites();
            // Check if already exists
            if (favorites.some(f => f.id === stop.id)) {
                return false;
            }
            favorites.push(stop);
            saveFavorites(favorites);
            renderFavorites();
            return true;
        }

        function removeFavorite(stopId) {
            let favorites = loadFavorites();
            favorites = favorites.filter(f => f.id !== stopId);
            // Keep at least one favorite
            if (favorites.length === 0) {
                favorites = [DEFAULT_STOPS[0]];
            }
            saveFavorites(favorites);

            // If removed stop was selected, switch to first favorite
            if (currentStop && currentStop.id === stopId) {
                selectStop(favorites[0]);
            }
            renderFavorites();
        }

        function openStopSelector() {
            const modal = document.getElementById('stopModal');
            modal.classList.add('visible');
            renderFavorites();

            // Focus search input
            setTimeout(() => {
                document.getElementById('stopSearchInput').focus();
            }, 100);
        }

        function closeStopSelector() {
            const modal = document.getElementById('stopModal');
            modal.classList.remove('visible');
            document.getElementById('stopSearchInput').value = '';
            document.getElementById('searchResults').innerHTML = '';
        }

        // Detect if a stop is a train station
        function isTrainStation(stopId, name) {
            const id = (stopId || '').toLowerCase();
            const nameLower = (name || '').toLowerCase();

            // Check if name contains train-related keywords
            if (nameLower.includes('station') || nameLower.includes('centraal')) {
                return true;
            }

            // NS station codes are typically short (2-5 chars) in format NL:S:xxx
            // Examples: NL:S:ut, NL:S:asd, NL:S:vtn, NL:S:ehv, NL:S:rtd
            const nsMatch = id.match(/^nl:s:([a-z]{2,6})$/);
            if (nsMatch) {
                return true;
            }

            return false;
        }

        function renderFavorites() {
            const container = document.getElementById('favoritesList');
            const favorites = loadFavorites();

            if (favorites.length === 0) {
                container.innerHTML = '<div class="favorites-empty">Nog geen favorieten toegevoegd</div>';
                return;
            }

            const busIcon = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="3" width="14" height="14" rx="2"/><path d="M5 8h14"/><path d="M8 8v5"/><path d="M16 8v5"/><path d="M7 17l-1.5 3"/><path d="M17 17l1.5 3"/><path d="M3 21h18"/></svg>';
            const trainIcon = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="3" width="12" height="14" rx="3"/><path d="M6 8h12"/><path d="M9 8v4"/><path d="M15 8v4"/><path d="M10 17l-2 4"/><path d="M14 17l2 4"/><path d="M3 21h18"/></svg>';

            container.innerHTML = favorites.map(stop => {
                const isActive = currentStop && currentStop.id === stop.id;
                const isTrain = stop.type === 'train' || isTrainStation(stop.id, stop.name);
                const icon = isTrain ? trainIcon : busIcon;
                const typeLabel = isTrain ? 'Station' : 'Bushalte';

                return `
                    <div class="favorite-item ${isActive ? 'active' : ''}" onclick="selectStop(${JSON.stringify(stop).replace(/"/g, '&quot;')})">
                        <div class="favorite-icon ${isTrain ? 'train' : ''}">${icon}</div>
                        <div class="favorite-info">
                            <div class="favorite-name">${stop.name}</div>
                            <div class="favorite-type">${typeLabel}</div>
                        </div>
                        <button class="favorite-delete" onclick="event.stopPropagation(); removeFavorite('${stop.id}')" aria-label="Verwijderen">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 6L6 18M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                `;
            }).join('');
        }

        // Popular NS stations for quick selection
        const POPULAR_STATIONS = [
            { id: 'NL:S:ut', name: 'Utrecht Centraal', type: 'train' },
            { id: 'NL:S:asd', name: 'Amsterdam Centraal', type: 'train' },
            { id: 'NL:S:rtd', name: 'Rotterdam Centraal', type: 'train' },
            { id: 'NL:S:ehv', name: 'Eindhoven', type: 'train' },
            { id: 'NL:S:ah', name: 'Arnhem Centraal', type: 'train' },
            { id: 'NL:S:amf', name: 'Amersfoort Centraal', type: 'train' },
            { id: 'NL:S:gvc', name: 'Den Haag Centraal', type: 'train' },
            { id: 'NL:S:ledn', name: 'Leiden Centraal', type: 'train' },
            { id: 'NL:S:zl', name: 'Zwolle', type: 'train' },
            { id: 'NL:S:gd', name: 'Gouda', type: 'train' },
            { id: 'NL:S:hvs', name: 'Hilversum', type: 'train' },
            { id: 'NL:S:asdz', name: 'Amsterdam Zuid', type: 'train' },
            { id: 'NL:S:shl', name: 'Schiphol Airport', type: 'train' },
            { id: 'NL:S:utzl', name: 'Utrecht Zuilen', type: 'train' },
            { id: 'NL:S:utlr', name: 'Utrecht Leidsche Rijn', type: 'train' },
            { id: 'NL:S:vtn', name: 'Vleuten', type: 'train' },
            { id: 'NL:S:drvn', name: 'Driebergen-Zeist', type: 'train' },
            { id: 'NL:S:uto', name: 'Utrecht Overvecht', type: 'train' },
            { id: 'NL:S:bhv', name: 'Bilthoven', type: 'train' },
            { id: 'NL:S:htnc', name: 'Houten Castellum', type: 'train' },
            { id: 'NL:S:htn', name: 'Houten', type: 'train' },
            { id: 'NL:S:bnc', name: 'Bunnik', type: 'train' },
            { id: 'NL:S:mrn', name: 'Maarssen', type: 'train' },
            { id: 'NL:S:bsmz', name: 'Breukelen', type: 'train' },
            { id: 'NL:S:wdn', name: 'Woerden', type: 'train' },
            { id: 'NL:S:hm', name: 'Harmelen', type: 'train' },
            { id: 'NL:S:dld', name: 'Delft', type: 'train' },
            { id: 'NL:S:nm', name: 'Nijmegen', type: 'train' },
            { id: 'NL:S:std', name: \"'s-Hertogenbosch\", type: 'train' },
            { id: 'NL:S:tb', name: 'Tilburg', type: 'train' },
            { id: 'NL:S:brd', name: 'Breda', type: 'train' },
            { id: 'NL:S:dtc', name: 'Dordrecht', type: 'train' },
            { id: 'NL:S:gn', name: 'Groningen', type: 'train' },
            { id: 'NL:S:lw', name: 'Leeuwarden', type: 'train' },
            { id: 'NL:S:es', name: 'Enschede', type: 'train' },
            { id: 'NL:S:ht', name: 'Heerlen', type: 'train' },
            { id: 'NL:S:mt', name: 'Maastricht', type: 'train' },
            { id: 'NL:S:vl', name: 'Venlo', type: 'train' },
            { id: 'NL:S:apd', name: 'Apeldoorn', type: 'train' },
            { id: 'NL:S:dvd', name: 'Deventer', type: 'train' },
            { id: 'NL:S:alm', name: 'Almere Centrum', type: 'train' },
            { id: 'NL:S:amr', name: 'Amersfoort Schothorst', type: 'train' },
            { id: 'NL:S:assp', name: 'Amsterdam Sloterdijk', type: 'train' },
            { id: 'NL:S:ass', name: 'Amsterdam Science Park', type: 'train' },
            { id: 'NL:S:asdm', name: 'Amsterdam Muiderpoort', type: 'train' },
            { id: 'NL:S:ampo', name: 'Amsterdam Amstel', type: 'train' },
            { id: 'NL:S:asb', name: 'Amsterdam Bijlmer ArenA', type: 'train' },
            { id: 'NL:S:duiz', name: 'Duivendrecht', type: 'train' },
            { id: 'NL:S:rai', name: 'Amsterdam RAI', type: 'train' },
        ];

        // Search stops - combines local station list with drgl.nl search
        async function searchStops(query) {
            if (!query || query.length < 2) {
                document.getElementById('searchResults').innerHTML = '';
                return;
            }

            const resultsContainer = document.getElementById('searchResults');
            resultsContainer.innerHTML = '<div class="search-loading">Zoeken...</div>';

            const queryLower = query.toLowerCase();
            const stops = [];

            // First: search in popular stations (instant results)
            POPULAR_STATIONS.forEach(station => {
                if (station.name.toLowerCase().includes(queryLower)) {
                    stops.push({ ...station, lat: null, lon: null });
                }
            });

            // Then: try to search drgl.nl for bus stops
            try {
                const searchUrl = `https://drgl.nl/stops?q=${encodeURIComponent(query)}`;
                const html = await fetchDrglData(searchUrl);

                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                doc.querySelectorAll('.list-group-item').forEach(item => {
                    const href = item.getAttribute('href') || '';
                    const stopMatch = href.match(/\/stop\/([^/?#]+)/);
                    if (!stopMatch) return;

                    const stopId = stopMatch[1];
                    // Skip if already in results (from popular stations)
                    if (stops.some(s => s.id === stopId)) return;

                    const nameEl = item.querySelector('.ott-stopname, .row');
                    const name = nameEl ? nameEl.textContent.trim() : item.textContent.trim().split('\n')[0];

                    if (name && stopId && name.length > 2) {
                        const isTrain = isTrainStation(stopId, name);
                        stops.push({
                            id: stopId,
                            name: name.substring(0, 50),
                            type: isTrain ? 'train' : 'bus',
                            lat: null,
                            lon: null
                        });
                    }
                });
            } catch (e) {
                console.log('drgl.nl search failed, using local results only:', e.message);
            }

            renderSearchResults(stops.slice(0, 10));
        }

        function renderSearchResults(stops) {
            const container = document.getElementById('searchResults');
            const favorites = loadFavorites();

            if (stops.length === 0) {
                container.innerHTML = '<div class="search-loading">Geen haltes gevonden</div>';
                return;
            }

            const busIcon = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="3" width="14" height="14" rx="2"/><path d="M5 8h14"/><path d="M8 8v5"/><path d="M16 8v5"/><path d="M7 17l-1.5 3"/><path d="M17 17l1.5 3"/><path d="M3 21h18"/></svg>';
            const trainIcon = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="3" width="12" height="14" rx="3"/><path d="M6 8h12"/><path d="M9 8v4"/><path d="M15 8v4"/><path d="M10 17l-2 4"/><path d="M14 17l2 4"/><path d="M3 21h18"/></svg>';

            container.innerHTML = stops.map(stop => {
                const isTrain = stop.type === 'train';
                const icon = isTrain ? trainIcon : busIcon;
                const typeLabel = isTrain ? 'Station' : 'Bushalte';
                const isFavorite = favorites.some(f => f.id === stop.id);

                return `
                    <div class="search-result-item" onclick="handleSearchResultClick(${JSON.stringify(stop).replace(/"/g, '&quot;')})">
                        <div class="search-result-icon ${isTrain ? 'train' : ''}">${icon}</div>
                        <div class="search-result-info">
                            <div class="search-result-name">${stop.name}</div>
                            <div class="search-result-type">${typeLabel}${isFavorite ? ' · ★ Favoriet' : ''}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function handleSearchResultClick(stop) {
            addFavorite(stop);
            selectStop(stop);
        }

        // Search input handler with debounce
        document.addEventListener('DOMContentLoaded', () => {
            const searchInput = document.getElementById('stopSearchInput');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        searchStops(e.target.value);
                    }, 300);
                });
            }

            // Close modal on Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const stopModal = document.getElementById('stopModal');
                    if (stopModal.classList.contains('visible')) {
                        closeStopSelector();
                    }
                }
            });

            // Close modal on backdrop click
            const stopModal = document.getElementById('stopModal');
            if (stopModal) {
                stopModal.addEventListener('click', (e) => {
                    if (e.target === stopModal) {
                        closeStopSelector();
                    }
                });
            }
        });

        // Initialize stops system
        initializeStops();

        // ===== END FAVORITES SYSTEM =====

        // Dynamic stop URLs based on current selection
        function getBusUrl() {
            if (!currentStop || currentStop.type === 'train') return null;
            return `https://drgl.nl/stop/${currentStop.id}/departurespanel`;
        }

        function getTrainUrl() {
            // Always show train from Vleuten as secondary
            return `https://drgl.nl/stop/NL:S:vtn/traindeparturespanel`;
        }

        function getCurrentStopCoords() {
            if (!currentStop) return null;
            return { lat: currentStop.lat, lon: currentStop.lon };
        }

        // Legacy constants for compatibility
        const BUS_STOP_COORDS = {
            'NL:S:51200123': { lat: 52.0839993, lon: 5.0132954 }
        };

        const REFRESH_INTERVAL = 15000;
        const POSITION_CACHE_TTL = 30000;
        const JOURNEY_CACHE_TTL = 30000;

        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?'
        ];
        const FETCH_TIMEOUT = 5000; // 5 seconden timeout per proxy
        let refreshTimer;
        const positionCache = new Map();
        const journeyStopsCache = new Map();
        const journeyProgressCache = new Map();
        let liveMap;
        let liveMarker;
        let liveMapTimer;
        let liveJourneyPath;
        let liveJourneyLabel;
        let liveJourneyRealtime = false;
        let liveRouteCoords;
        let liveRouteLine;
        let liveRemainingLine;
        let liveStopMarker;
        let liveMarkerIcon;

        // Fetch HTML van drgl.nl via CORS proxy (parallel racing)
        async function fetchDrglData(url) {
            const fetchWithTimeout = async (proxyUrl) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

                try {
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error('Response not ok');
                    return response.text();
                } catch (e) {
                    clearTimeout(timeoutId);
                    throw e;
                }
            };

            const proxyUrls = CORS_PROXIES.map(proxy => proxy + encodeURIComponent(url));

            try {
                // Race beide proxies parallel - de snelste wint
                return await Promise.any(proxyUrls.map(fetchWithTimeout));
            } catch (e) {
                throw new Error('All proxies failed');
            }
        }

        async function fetchDrglJson(url) {
            const fetchWithTimeout = async (proxyUrl) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

                try {
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error('Response not ok');
                    return response.json();
                } catch (e) {
                    clearTimeout(timeoutId);
                    throw e;
                }
            };

            const proxyUrls = CORS_PROXIES.map(proxy => proxy + encodeURIComponent(url));

            try {
                return await Promise.any(proxyUrls.map(fetchWithTimeout));
            } catch (e) {
                throw new Error('All proxies failed');
            }
        }

        function normalizeStopName(name) {
            return (name || '').toLowerCase().replace(/\s+/g, ' ').trim();
        }

        async function fetchJourneyStops(journeyPath) {
            const cached = journeyStopsCache.get(journeyPath);
            const now = Date.now();
            if (cached && now - cached.checkedAt < JOURNEY_CACHE_TTL) return cached.stops;

            const journeyUrl = `https://drgl.nl${journeyPath}`;
            const html = await fetchDrglData(journeyUrl);
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const stops = [];

            doc.querySelectorAll('#ott-main-journeycalls .list-group-item').forEach(item => {
                const href = item.getAttribute('href') || '';
                const stopMatch = href.match(/\/stop\/([^/?#]+)/);
                const nameEl = item.querySelector('.row.col-md-8.col-xs-8') || item.querySelector('.row.col-md-8');
                const name = nameEl ? nameEl.textContent.trim() : item.textContent.trim();

                if (stopMatch) {
                    stops.push({
                        stopId: stopMatch[1],
                        name
                    });
                }
            });

            journeyStopsCache.set(journeyPath, { stops, checkedAt: now });
            return stops;
        }

        async function fetchJourneyProgress(journeyPath) {
            const cached = journeyProgressCache.get(journeyPath);
            const now = Date.now();
            if (cached && now - cached.checkedAt < JOURNEY_CACHE_TTL) return cached.text;

            const progressUrl = `https://drgl.nl${journeyPath.replace(/\/$/, '')}/progress`;
            const html = await fetchDrglData(progressUrl);
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const text = doc.querySelector('.ott-btm-vjprogress')?.textContent?.trim() || '';

            journeyProgressCache.set(journeyPath, { text, checkedAt: now });
            return text;
        }

        async function getRemainingStopsCount(journeyPath, targetStopId) {
            if (!journeyPath || !targetStopId) return null;

            const [stops, progressText] = await Promise.all([
                fetchJourneyStops(journeyPath),
                fetchJourneyProgress(journeyPath)
            ]);

            if (!stops.length) return null;

            const targetIndex = stops.findIndex(stop => stop.stopId === targetStopId);
            if (targetIndex < 0) return null;

            const match = progressText.match(/tussen\s+(.+)\s+en\s+(.+)/i);
            const nextStopName = match ? normalizeStopName(match[2]) : '';
            if (!nextStopName) return null;

            const nextIndex = stops.findIndex(stop => {
                const stopName = normalizeStopName(stop.name);
                return stopName === nextStopName ||
                    stopName.includes(nextStopName) ||
                    nextStopName.includes(stopName);
            });

            if (nextIndex < 0) return null;
            if (targetIndex < nextIndex) return 0;

            return targetIndex - nextIndex + 1;
        }

        // Parse HTML naar departure objecten
        function parseDrglHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const departures = [];
            const now = new Date();

            doc.querySelectorAll('.list-group-item').forEach(row => {
                try {
                    const journeyPath = row.getAttribute('href') || '';
                    if (journeyPath && !journeyPath.startsWith('/journey/')) return;

                    // Tijd ophalen (bevat ook eventuele vertraging zoals "21:10 +11")
                    const timeEl = row.querySelector('.ott-departure-time');
                    const timeText = timeEl?.textContent?.trim() || '';

                    // Lijnnummer
                    const lineEl = row.querySelector('.ott-linecode');
                    const line = lineEl?.textContent?.trim() || '?';

                    // Bestemming
                    const destEl = row.querySelector('.ott-destination');
                    const destination = destEl?.textContent?.trim() || 'Onbekend';

                    // Vertraging uit tijdtekst halen (bijv. "21:10 +11" -> 11)
                    const delayMatch = timeText.match(/\+(\d+)/);
                    const delayMinutes = delayMatch ? parseInt(delayMatch[1]) : 0;

                    // Status (rijdend of gepland)
                    const isRealtime = timeEl?.classList.contains('ott-tripstatus-driving') || false;
                    const isCancelled = row.querySelector('.ott-departure-cancelled') !== null;

                    // Parse tijd naar Date object
                    // drgl.nl toont de GEPLANDE tijd, dus we moeten vertraging erbij optellen
                    let targetTime = null; // geplande tijd
                    let expectedTime = null; // werkelijke verwachte tijd (gepland + vertraging)

                    const timeParts = timeText.match(/(\d{1,2}):(\d{2})/);
                    if (timeParts) {
                        targetTime = new Date(now);
                        targetTime.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0, 0);

                        // Als tijd in het verleden ligt (meer dan 2 uur), is het morgen
                        if (targetTime < now - 2 * 60 * 60000) {
                            targetTime.setDate(targetTime.getDate() + 1);
                        }

                        // Werkelijke vertrektijd = geplande tijd + vertraging
                        expectedTime = new Date(targetTime.getTime() + delayMinutes * 60000);
                    }

                    if (!expectedTime) return;

                    // Filter: toon bussen die nog moeten vertrekken (met kleine marge)
                    const minutes = Math.floor((expectedTime - now) / 60000);
                    if (minutes < -1 || minutes > 120) return;

                    departures.push({
                        line,
                        destination,
                        expectedTime,
                        targetTime,
                        minutes,
                        delayMinutes,
                        isRealtime,
                        cancelled: isCancelled,
                        direction: getDirectionFromDestination(destination),
                        journeyPath
                    });
                } catch (e) {
                    console.warn('Failed to parse row:', e);
                }
            });

            return departures;
        }

        // Parse trein HTML naar departure objecten
        function parseTrainHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const departures = [];
            const now = new Date();

            doc.querySelectorAll('.list-group-item').forEach(row => {
                try {
                    // Tijd ophalen
                    const timeEl = row.querySelector('.ott-departure-time');
                    const timeText = timeEl?.textContent?.trim() || '';

                    // Treintype (Sprinter, Intercity, etc.)
                    const typeEl = row.querySelector('.ott-productcategory');
                    const typeText = typeEl?.textContent?.trim() || '';
                    const trainType = typeText.split('•')[0]?.trim() || 'Trein';

                    // Bestemming
                    const destEl = row.querySelector('.ott-destination');
                    const destination = destEl?.textContent?.trim() || 'Onbekend';

                    // Perron
                    const platformEl = row.querySelector('.ott-trainplatform');
                    const platform = platformEl?.textContent?.trim() || '';

                    // Vertraging
                    const delayMatch = timeText.match(/\+(\d+)/);
                    const delayMinutes = delayMatch ? parseInt(delayMatch[1]) : 0;

                    // Status
                    const isRealtime = timeEl?.classList.contains('ott-tripstatus-driving') || false;
                    const isCancelled = row.querySelector('.ott-departure-cancelled') !== null ||
                                       row.textContent.includes('Rijdt niet');

                    // Parse tijd
                    let targetTime = null;
                    let expectedTime = null;

                    const timeParts = timeText.match(/(\d{1,2}):(\d{2})/);
                    if (timeParts) {
                        targetTime = new Date(now);
                        targetTime.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0, 0);

                        if (targetTime < now - 2 * 60 * 60000) {
                            targetTime.setDate(targetTime.getDate() + 1);
                        }

                        expectedTime = new Date(targetTime.getTime() + delayMinutes * 60000);
                    }

                    if (!expectedTime) return;

                    const minutes = Math.floor((expectedTime - now) / 60000);
                    if (minutes < -1 || minutes > 120) return;

                    departures.push({
                        line: trainType,
                        destination,
                        platform,
                        expectedTime,
                        targetTime,
                        minutes,
                        delayMinutes,
                        isRealtime,
                        cancelled: isCancelled,
                        type: 'train'
                    });
                } catch (e) {
                    console.warn('Failed to parse train row:', e);
                }
            });

            return departures;
        }

        function getDirectionFromDestination(destination) {
            const dest = destination?.toLowerCase() || '';
            if (dest.includes('utrecht') || dest.includes('uithof') || dest.includes('wkz') ||
                dest.includes('science') || dest.includes('vaartsche') || dest.includes('p+r') ||
                dest.includes('bilthoven') || dest.includes('meernbrug')) {
                return 'utrecht';
            }
            return 'vleuten';
        }

        function formatTime(date) {
            if (!date) return '--:--';
            return date.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
        }

        function getTimeClass(minutes) {
            if (minutes <= 0) return 'now';
            if (minutes <= 5) return 'soon';
            return '';
        }

        async function loadDepartures() {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const content = document.getElementById('content');

            try {
                const busUrl = getBusUrl();
                const trainUrl = getTrainUrl();

                // Determine what to fetch based on current stop type
                let busDepartures = [];
                let trainDepartures = [];

                if (currentStop && currentStop.type === 'train') {
                    // For train stations, fetch train data from that station
                    const stationUrl = `https://drgl.nl/stop/${currentStop.id}/traindeparturespanel`;
                    const trainHtml = await fetchDrglData(stationUrl).catch(() => '');
                    trainDepartures = parseTrainHtml(trainHtml);
                } else {
                    // For bus stops, fetch both bus and train data
                    const [busHtml, trainHtml] = await Promise.all([
                        busUrl ? fetchDrglData(busUrl).catch(() => '') : Promise.resolve(''),
                        fetchDrglData(trainUrl).catch(() => '')
                    ]);

                    busDepartures = parseDrglHtml(busHtml);
                    trainDepartures = parseTrainHtml(trainHtml);
                }

                console.log(`DRGL: ${busDepartures.length} bus departures, ${trainDepartures.length} train departures`);

                // Sort en filter bus duplicaten
                busDepartures.sort((a, b) => a.expectedTime - b.expectedTime);

                const uniqueBusDepartures = busDepartures.filter((dep, index, arr) => {
                    return !arr.slice(0, index).some(
                        prev => prev.line === dep.line &&
                               prev.destination === dep.destination &&
                               Math.abs(prev.minutes - dep.minutes) <= 1
                    );
                });

                const utrechtDepartures = uniqueBusDepartures.filter(d => d.direction === 'utrecht').slice(0, 5);
                const vleutenDepartures = uniqueBusDepartures.filter(d => d.direction === 'vleuten').slice(0, 5);

                // Sort treinen
                trainDepartures.sort((a, b) => a.expectedTime - b.expectedTime);
                const trainList = trainDepartures.slice(0, 6);

                renderDepartures(utrechtDepartures, vleutenDepartures, trainList);

                statusDot.classList.remove('error');
                const timeStr = new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                statusText.textContent = `Bijgewerkt ${timeStr}`;

            } catch (error) {
                console.error('Error loading departures:', error);
                statusDot.classList.add('error');
                statusText.textContent = 'Verbinding mislukt';
                content.innerHTML = `
                    <div class="error-message">
                        <p>Kon vertrektijden niet laden.</p>
                        <p style="margin-top: 0.5rem; font-size: 0.85rem;">Probeer het opnieuw of controleer je internetverbinding.</p>
                    </div>
                `;
            }

        }

        function renderDepartures(utrechtDepartures, vleutenDepartures, trainDepartures) {
            const content = document.getElementById('content');

            let html = '';

            // Check if current stop is a train station
            const isTrainStation = currentStop && currentStop.type === 'train';

            if (isTrainStation) {
                // Only show train departures for train stations
                const stationName = currentStop.name.replace(/^Station\s*/i, '');
                html += renderSection('train', `Trein vanaf ${stationName}`, trainDepartures, 'train');
            } else {
                // Show bus departures grouped by direction
                html += renderSection('utrecht', 'Bus naar Utrecht', utrechtDepartures, 'bus');
                html += renderSection('vleuten', 'Bus naar Vleuten', vleutenDepartures, 'bus');

                // Treinen vanaf station Vleuten
                html += renderSection('train', 'Trein vanaf Vleuten', trainDepartures, 'train');
            }

            content.innerHTML = html;

            // Add click handlers for expanding sections
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const section = header.closest('.departures-section');
                    section.classList.toggle('expanded');
                });
            });

            // Live positie badges en kaart-interactie
            const busDepartures = [...utrechtDepartures, ...vleutenDepartures];
            updateLiveIndicators(busDepartures);

            document.querySelectorAll('.departure-card[data-journey]').forEach(card => {
                card.addEventListener('click', () => {
                    if (card.dataset.live !== 'true') return;
                    openLiveMap(
                        card.dataset.journey,
                        card.dataset.line,
                        card.dataset.destination,
                        card.dataset.realtime === 'true'
                    );
                });
            });
        }

        function renderSection(id, title, departures, type) {
            const first = departures[0];
            const hasMore = departures.length > 0;

            let timeDisplay = '--';
            let timeClass = '';
            let timeUnit = '';
            let preview = 'Geen vertrektijden';

            if (first && !first.cancelled) {
                if (first.minutes <= 0) {
                    timeDisplay = 'Nu';
                    timeClass = 'now';
                } else {
                    timeDisplay = first.minutes.toString();
                    timeUnit = 'min';
                    if (first.minutes <= 5) timeClass = 'soon';
                }
                preview = `<span class="line">${first.line}</span> naar ${first.destination}`;
            } else if (first && first.cancelled) {
                preview = `<span class="line">${first.line}</span> vervalt`;
            }

            const busIcon = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="3" width="14" height="14" rx="2"/><path d="M5 8h14"/><path d="M8 8v5"/><path d="M16 8v5"/><path d="M7 17l-1.5 3"/><path d="M17 17l1.5 3"/><path d="M3 21h18"/></svg>';
            const trainIcon = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="3" width="12" height="14" rx="3"/><path d="M6 8h12"/><path d="M9 8v4"/><path d="M15 8v4"/><path d="M10 17l-2 4"/><path d="M14 17l2 4"/><path d="M3 21h18"/></svg>';

            return `
                <div class="departures-section" id="section-${id}">
                    <div class="section-header">
                        <div class="direction-icon ${type === 'train' ? 'train' : ''}">
                            ${type === 'train' ? trainIcon : busIcon}
                        </div>
                        <div class="header-info">
                            <div class="direction-title">${title}</div>
                            <div class="next-departure-preview">${preview}</div>
                        </div>
                        <div class="header-time">
                            <div class="header-time-value ${timeClass}">${timeDisplay}</div>
                            ${timeUnit ? `<div class="header-time-unit">${timeUnit}</div>` : ''}
                        </div>
                        ${hasMore ? `
                            <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M6 9l6 6 6-6"/>
                            </svg>
                        ` : '<div style="width: 20px"></div>'}
                    </div>
                    ${hasMore ? `
                        <div class="departure-list">
                            <div class="departure-list-inner">
                                ${departures.map(dep => type === 'train' ? renderTrainCard(dep) : renderDepartureCard(dep)).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function getStatusInfo(departure) {
            if (departure.cancelled) {
                return { class: 'major-delay', label: 'Vervalt' };
            }
            if (!departure.isRealtime) {
                return { class: 'on-time', label: 'Gepland' };
            }
            if (departure.delayMinutes <= 1) {
                return { class: 'on-time', label: 'Op tijd' };
            }
            if (departure.delayMinutes <= 5) {
                return { class: 'slight-delay', label: `+${departure.delayMinutes} min` };
            }
            return { class: 'major-delay', label: `+${departure.delayMinutes} min` };
        }

        function renderDepartureCard(departure) {
            const timeClass = departure.cancelled ? '' : getTimeClass(departure.minutes);
            const statusInfo = getStatusInfo(departure);

            let timeDisplay;
            if (departure.cancelled) {
                timeDisplay = '--';
            } else if (departure.minutes <= 0) {
                timeDisplay = 'Nu';
            } else {
                timeDisplay = departure.minutes.toString();
            }

            const journeyAttr = departure.journeyPath
                ? `data-journey="${departure.journeyPath}" data-live="false" data-realtime="${departure.isRealtime ? 'true' : 'false'}"`
                : '';

            return `
                <div class="departure-card ${departure.cancelled ? 'cancelled' : ''}" ${journeyAttr} data-line="${departure.line}" data-destination="${departure.destination}">
                    <div class="line-badge">${departure.line}</div>
                    <div class="departure-info">
                        <div class="destination">${departure.destination}</div>
                        <div class="status-indicator">
                            ${departure.journeyPath ? '<span class="live-indicator" hidden>Live</span>' : ''}
                            <span class="status-dot-small ${statusInfo.class}"></span>
                            <span class="status-label ${statusInfo.class}">${statusInfo.label}</span>
                        </div>
                    </div>
                    <div class="departure-time">
                        ${departure.cancelled ?
                            '<div class="cancelled-label">Vervalt</div>' :
                            `<div class="time-value ${timeClass}">${timeDisplay}</div>
                             ${departure.minutes > 0 ? '<div class="time-unit">min</div>' : ''}`
                        }
                        <div class="actual-time">${formatTime(departure.expectedTime)}</div>
                    </div>
                </div>
            `;
        }

        function getTrainBadgeLabel(line) {
            const normalized = (line || '').toLowerCase();
            if (normalized.includes('sprinter')) return 'S';
            if (normalized.includes('intercity')) return 'I';
            return line || '?';
        }

        function renderTrainCard(departure) {
            const timeClass = departure.cancelled ? '' : getTimeClass(departure.minutes);
            const statusInfo = getStatusInfo(departure);
            const badgeLabel = getTrainBadgeLabel(departure.line);

            let timeDisplay;
            if (departure.cancelled) {
                timeDisplay = '--';
            } else if (departure.minutes <= 0) {
                timeDisplay = 'Nu';
            } else {
                timeDisplay = departure.minutes.toString();
            }

            return `
                <div class="departure-card ${departure.cancelled ? 'cancelled' : ''}">
                    <div class="line-badge train">${badgeLabel}</div>
                    <div class="departure-info">
                        <div class="destination">${departure.destination}</div>
                        <div class="status-indicator">
                            ${departure.platform ? `<span class="platform-badge">Spoor ${departure.platform}</span>` : ''}
                            <span class="status-dot-small ${statusInfo.class}"></span>
                            <span class="status-label ${statusInfo.class}">${statusInfo.label}</span>
                        </div>
                    </div>
                    <div class="departure-time">
                        ${departure.cancelled ?
                            '<div class="cancelled-label">Vervalt</div>' :
                            `<div class="time-value ${timeClass}">${timeDisplay}</div>
                             ${departure.minutes > 0 ? '<div class="time-unit">min</div>' : ''}`
                        }
                        <div class="actual-time">${formatTime(departure.expectedTime)}</div>
                    </div>
                </div>
            `;
        }

        function buildPositionUrl(journeyPath) {
            if (!journeyPath) return '';
            const basePath = journeyPath.endsWith('/') ? journeyPath.slice(0, -1) : journeyPath;
            return `https://drgl.nl${basePath}/position`;
        }

        function buildPolylineUrl(journeyPath) {
            if (!journeyPath) return '';
            const basePath = journeyPath.endsWith('/') ? journeyPath.slice(0, -1) : journeyPath;
            return `https://drgl.nl${basePath}/polyline`;
        }

        function decodePolyline(encoded) {
            let index = 0;
            let lat = 0;
            let lon = 0;
            const coords = [];

            while (index < encoded.length) {
                let result = 0;
                let shift = 0;
                let byte;

                do {
                    byte = encoded.charCodeAt(index++) - 63;
                    result |= (byte & 0x1f) << shift;
                    shift += 5;
                } while (byte >= 0x20);

                const deltaLat = (result & 1) ? ~(result >> 1) : (result >> 1);
                lat += deltaLat;

                result = 0;
                shift = 0;
                do {
                    byte = encoded.charCodeAt(index++) - 63;
                    result |= (byte & 0x1f) << shift;
                    shift += 5;
                } while (byte >= 0x20);

                const deltaLon = (result & 1) ? ~(result >> 1) : (result >> 1);
                lon += deltaLon;

                coords.push([lat / 1e5, lon / 1e5]);
            }

            return coords;
        }

        function findClosestIndex(coords, target) {
            let bestIndex = 0;
            let bestDist = Infinity;
            const [tLat, tLon] = target;

            coords.forEach(([lat, lon], index) => {
                const dLat = lat - tLat;
                const dLon = lon - tLon;
                const dist = dLat * dLat + dLon * dLon;
                if (dist < bestDist) {
                    bestDist = dist;
                    bestIndex = index;
                }
            });

            return bestIndex;
        }

        function clearRouteLayers() {
            if (liveRouteLine) {
                liveRouteLine.remove();
                liveRouteLine = null;
            }
            if (liveRemainingLine) {
                liveRemainingLine.remove();
                liveRemainingLine = null;
            }
            if (liveStopMarker) {
                liveStopMarker.remove();
                liveStopMarker = null;
            }
            liveRouteCoords = null;
        }

        async function loadJourneyRoute() {
            if (!liveJourneyPath) return;
            const polylineUrl = buildPolylineUrl(liveJourneyPath);
            if (!polylineUrl) return;

            try {
                const data = await fetchDrglJson(polylineUrl);
                const polylines = Array.isArray(data?.polyLines) ? data.polyLines : [];
                if (!polylines.length) return;

                const coords = polylines.flatMap(line => decodePolyline(line));
                if (!coords.length) return;

                liveRouteCoords = coords;

                if (liveRouteLine) {
                    liveRouteLine.setLatLngs(coords);
                } else {
                    liveRouteLine = L.polyline(coords, {
                        color: '#94a3b8',
                        weight: 4,
                        opacity: 0.6
                    }).addTo(liveMap);
                }

                const stopCoords = getCurrentStopCoords() || BUS_STOP_COORDS['NL:S:51200123'];
                if (stopCoords && stopCoords.lat && stopCoords.lon) {
                    const stopLatLng = [stopCoords.lat, stopCoords.lon];
                    if (liveStopMarker) {
                        liveStopMarker.setLatLng(stopLatLng);
                    } else {
                        liveStopMarker = L.circleMarker(stopLatLng, {
                            radius: 6,
                            color: '#1d4ed8',
                            fillColor: '#3b82f6',
                            fillOpacity: 0.9
                        }).addTo(liveMap);
                    }
                }
            } catch (e) {
                // ignore route errors
            }
        }

        async function fetchLivePositionStatus(journeyPath) {
            const cached = positionCache.get(journeyPath);
            const now = Date.now();
            if (cached && now - cached.checkedAt < POSITION_CACHE_TTL) return cached;

            const positionUrl = buildPositionUrl(journeyPath);
            if (!positionUrl) throw new Error('Missing journey path');

            const data = await fetchDrglJson(positionUrl);
            const hasPosition = Array.isArray(data?.features) && data.features.length > 0;
            const result = { hasPosition, checkedAt: now };
            positionCache.set(journeyPath, result);
            return result;
        }

        function updateLiveIndicators(departures) {
            const tasks = departures
                .filter(dep => dep.journeyPath)
                .slice(0, 10)
                .map(async dep => {
                    try {
                        const status = await fetchLivePositionStatus(dep.journeyPath);
                        if (!status.hasPosition) return;
                        const card = document.querySelector(`.departure-card[data-journey="${CSS.escape(dep.journeyPath)}"]`);
                        if (!card) return;
                        card.dataset.live = 'true';
                        card.classList.add('live-available');
                        const badge = card.querySelector('.live-indicator');
                        if (badge) badge.hidden = false;
                    } catch (e) {
                        // ignore per-departure errors
                    }
                });

            Promise.allSettled(tasks);
        }

        function ensureMap() {
            if (liveMap) return;
            liveMap = L.map('liveMap', { zoomControl: true });
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 19,
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
            }).addTo(liveMap);
        }

        function startLiveMapTimer() {
            clearInterval(liveMapTimer);
            liveMapTimer = setInterval(refreshLiveMap, 10000);
        }

        async function openLiveMap(journeyPath, line, destination, isRealtime) {
            const modal = document.getElementById('mapModal');
            const meta = document.getElementById('mapMeta');
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
            meta.textContent = 'Laden...';
            const isNewJourney = liveJourneyPath && liveJourneyPath !== journeyPath;
            if (isNewJourney) {
                clearRouteLayers();
            }
            liveJourneyPath = journeyPath;
            liveJourneyLabel = `${line} naar ${destination}`;
            liveJourneyRealtime = Boolean(isRealtime);

            ensureMap();
            setTimeout(() => liveMap.invalidateSize(), 100);

            await loadJourneyRoute();
            await refreshLiveMap();
            startLiveMapTimer();
        }

        function closeMapModal() {
            const modal = document.getElementById('mapModal');
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            clearInterval(liveMapTimer);
            liveMapTimer = null;
            liveJourneyPath = null;
            liveJourneyLabel = null;
            liveJourneyRealtime = false;
            const badge = document.getElementById('mapStopsBadge');
            if (badge) {
                badge.hidden = true;
                badge.textContent = '';
            }
            clearRouteLayers();
        }

        function updateRemainingRoute(currentLat, currentLon) {
            if (!liveRouteCoords || !liveRouteCoords.length) return false;

            const currentIndex = findClosestIndex(liveRouteCoords, [currentLat, currentLon]);
            let remainingCoords = liveRouteCoords.slice(currentIndex);
            let stopPassed = false;

            const stopCoords = getCurrentStopCoords() || BUS_STOP_COORDS['NL:S:51200123'];
            if (stopCoords && stopCoords.lat && stopCoords.lon) {
                const stopIndex = findClosestIndex(liveRouteCoords, [stopCoords.lat, stopCoords.lon]);
                if (stopIndex >= currentIndex) {
                    remainingCoords = liveRouteCoords.slice(currentIndex, stopIndex + 1);
                } else {
                    stopPassed = true;
                }
            }

            if (liveRemainingLine) {
                liveRemainingLine.setLatLngs(remainingCoords);
            } else {
                liveRemainingLine = L.polyline(remainingCoords, {
                    color: '#3b82f6',
                    weight: 5,
                    opacity: 0.9
                }).addTo(liveMap);
            }

            return stopPassed;
        }

        async function refreshLiveMap() {
            const meta = document.getElementById('mapMeta');
            const badge = document.getElementById('mapStopsBadge');
            const mapSheet = document.querySelector('.map-sheet');
            if (!liveJourneyPath) return;
            try {
                const positionUrl = buildPositionUrl(liveJourneyPath);
                const data = await fetchDrglJson(positionUrl);
                const feature = data?.features?.[0];
                const coords = feature?.geometry?.coordinates;
                liveJourneyRealtime = Boolean(feature);
                if (mapSheet) {
                    mapSheet.classList.toggle('realtime-off', !liveJourneyRealtime);
                }
                if (!Array.isArray(coords) || coords.length < 2) {
                    meta.textContent = 'Geen live positie beschikbaar.';
                    if (badge && badge.textContent) {
                        badge.hidden = false;
                    }
                    return;
                }
                const [lon, lat] = coords;
                if (liveMarker) {
                    liveMarker.setLatLng([lat, lon]);
                } else {
                    if (!liveMarkerIcon) {
                        liveMarkerIcon = L.divIcon({
                            className: 'live-marker',
                            html: '<span class="live-marker-core"></span>',
                            iconSize: [22, 22],
                            iconAnchor: [11, 11]
                        });
                    }
                    liveMarker = L.marker([lat, lon], { icon: liveMarkerIcon }).addTo(liveMap);
                }
                liveMap.setView([lat, lon], 15);
                const stopPassed = updateRemainingRoute(lat, lon);
                let remainingStops = null;
                if (liveJourneyRealtime && currentStop) {
                    try {
                        remainingStops = await getRemainingStopsCount(liveJourneyPath, currentStop.id);
                    } catch (e) {
                        remainingStops = null;
                    }
                }
                const timeStr = new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                if (stopPassed && liveJourneyRealtime) {
                    meta.textContent = `${liveJourneyLabel} · halte al gepasseerd · bijgewerkt ${timeStr}`;
                    if (badge) {
                        badge.hidden = false;
                        badge.textContent = 'Halte gepasseerd';
                    }
                } else if (remainingStops !== null && liveJourneyRealtime) {
                    const stopLabel = remainingStops === 0 ? 'Laatste halte' : `Nog ${remainingStops} haltes`;
                    meta.textContent = `${liveJourneyLabel} · ${stopLabel} · bijgewerkt ${timeStr}`;
                    if (badge) {
                        badge.hidden = false;
                        badge.textContent = stopLabel;
                    }
                } else {
                    meta.textContent = `${liveJourneyLabel} · bijgewerkt ${timeStr}`;
                    if (badge) {
                        badge.hidden = false;
                    }
                }
            } catch (e) {
                meta.textContent = 'Kon live positie niet laden.';
                if (badge && badge.textContent) {
                    badge.hidden = false;
                }
            }
        }

        // Refresh knop handler
        function handleRefreshClick() {
            const statusText = document.getElementById('statusText');
            const refreshBtn = document.getElementById('refreshBtn');

            statusText.textContent = 'Verversen...';
            refreshBtn.classList.add('spinning');

            const minSpinTime = new Promise(resolve => setTimeout(resolve, 500));

            Promise.all([loadDepartures(), minSpinTime]).finally(() => {
                refreshBtn.classList.remove('spinning');
            });
        }

        // Initial load
        loadDepartures();

        // Auto-refresh
        refreshTimer = setInterval(loadDepartures, REFRESH_INTERVAL);

        // Visibility API - pause refresh when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                clearInterval(refreshTimer);
                clearInterval(liveMapTimer);
            } else {
                loadDepartures();
                refreshTimer = setInterval(loadDepartures, REFRESH_INTERVAL);
                if (liveJourneyPath && document.getElementById('mapModal')?.classList.contains('visible')) {
                    refreshLiveMap();
                    startLiveMapTimer();
                }
            }
        });
    </script>
</body>
</html>
