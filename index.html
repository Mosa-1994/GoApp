<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OV Tijden De Meern & Vleuten</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
    <link rel="apple-touch-icon" href="assets/goapp-icoon.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="theme-color" content="#0a0a0b">
</head>
<body>
    <div class="container">
        <header>
            <h1>OV Tijden</h1>
        </header>

        <div class="status-bar">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Verbonden</span>
            <button class="refresh-btn" id="refreshBtn" onclick="handleRefreshClick()" aria-label="Ververs">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
                </svg>
            </button>
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Wissel thema">
                <svg class="theme-icon-sun" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"/>
                    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                </svg>
                <svg class="theme-icon-moon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
                </svg>
            </button>
        </div>

        <div id="content">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Laden...</p>
            </div>
        </div>

        <footer>
            <a href="https://drgl.nl" target="_blank">drgl.nl</a>
        </footer>
    </div>

        <div class="map-modal" id="mapModal" aria-hidden="true">
        <div class="map-sheet" role="dialog" aria-modal="true" aria-label="Live positie">
            <div class="map-header">
                <div class="map-title">
                    Live positie
                    <span class="map-badge" id="mapStopsBadge" hidden></span>
                </div>
                <button class="map-close" onclick="closeMapModal()" aria-label="Sluit kaart">✕</button>
            </div>
            <div id="liveMap" class="map-canvas"></div>
            <div id="mapMeta" class="map-meta">Laden...</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
        // Theme toggle
        function updateThemeColor(theme) {
            const themeColor = theme === 'light' ? '#f1f5f9' : '#0a0a0b';
            const metaTheme = document.querySelector('meta[name="theme-color"]');
            if (metaTheme) {
                metaTheme.setAttribute('content', themeColor);
            }
        }

        function initTheme() {
            try {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    document.documentElement.setAttribute('data-theme', savedTheme);
                    updateThemeColor(savedTheme);
                } else {
                    // Set default theme explicitly
                    document.documentElement.setAttribute('data-theme', 'dark');
                    updateThemeColor('dark');
                }
            } catch (e) {
                // localStorage not available, use dark as default
                document.documentElement.setAttribute('data-theme', 'dark');
                updateThemeColor('dark');
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            updateThemeColor(newTheme);
            try {
                localStorage.setItem('theme', newTheme);
            } catch (e) {
                // localStorage not available, theme will reset on reload
            }
        }

        // Initialize theme on load
        initTheme();

        // Bus halte
        const BUS_STOP_AREA = 'NL:S:51200123';
        const BUS_URL = `https://drgl.nl/stop/${BUS_STOP_AREA}/departurespanel`;
        const BUS_STOP_COORDS = {
            'NL:S:51200123': { lat: 52.0839993, lon: 5.0132954 }
        };

        // Trein station Vleuten
        const TRAIN_STOP_AREA = 'NL:S:vtn';
        const TRAIN_URL = `https://drgl.nl/stop/${TRAIN_STOP_AREA}/traindeparturespanel`;

        const REFRESH_INTERVAL = 15000;
        const POSITION_CACHE_TTL = 30000;
        const JOURNEY_CACHE_TTL = 30000;

        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?'
        ];
        const FETCH_TIMEOUT = 5000; // 5 seconden timeout per proxy
        let refreshTimer;
        const positionCache = new Map();
        const journeyStopsCache = new Map();
        const journeyProgressCache = new Map();
        let liveMap;
        let liveMarker;
        let liveMapTimer;
        let liveJourneyPath;
        let liveJourneyLabel;
        let liveJourneyRealtime = false;
        let liveRouteCoords;
        let liveRouteLine;
        let liveRemainingLine;
        let liveStopMarker;
        let liveMarkerIcon;

        // Fetch HTML van drgl.nl via CORS proxy (parallel racing)
        async function fetchDrglData(url) {
            const fetchWithTimeout = async (proxyUrl) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

                try {
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error('Response not ok');
                    return response.text();
                } catch (e) {
                    clearTimeout(timeoutId);
                    throw e;
                }
            };

            const proxyUrls = CORS_PROXIES.map(proxy => proxy + encodeURIComponent(url));

            try {
                // Race beide proxies parallel - de snelste wint
                return await Promise.any(proxyUrls.map(fetchWithTimeout));
            } catch (e) {
                throw new Error('All proxies failed');
            }
        }

        async function fetchDrglJson(url) {
            const fetchWithTimeout = async (proxyUrl) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

                try {
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error('Response not ok');
                    return response.json();
                } catch (e) {
                    clearTimeout(timeoutId);
                    throw e;
                }
            };

            const proxyUrls = CORS_PROXIES.map(proxy => proxy + encodeURIComponent(url));

            try {
                return await Promise.any(proxyUrls.map(fetchWithTimeout));
            } catch (e) {
                throw new Error('All proxies failed');
            }
        }

        function normalizeStopName(name) {
            return (name || '').toLowerCase().replace(/\s+/g, ' ').trim();
        }

        async function fetchJourneyStops(journeyPath) {
            const cached = journeyStopsCache.get(journeyPath);
            const now = Date.now();
            if (cached && now - cached.checkedAt < JOURNEY_CACHE_TTL) return cached.stops;

            const journeyUrl = `https://drgl.nl${journeyPath}`;
            const html = await fetchDrglData(journeyUrl);
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const stops = [];

            doc.querySelectorAll('#ott-main-journeycalls .list-group-item').forEach(item => {
                const href = item.getAttribute('href') || '';
                const stopMatch = href.match(/\/stop\/([^/?#]+)/);
                const nameEl = item.querySelector('.row.col-md-8.col-xs-8') || item.querySelector('.row.col-md-8');
                const name = nameEl ? nameEl.textContent.trim() : item.textContent.trim();

                if (stopMatch) {
                    stops.push({
                        stopId: stopMatch[1],
                        name
                    });
                }
            });

            journeyStopsCache.set(journeyPath, { stops, checkedAt: now });
            return stops;
        }

        async function fetchJourneyProgress(journeyPath) {
            const cached = journeyProgressCache.get(journeyPath);
            const now = Date.now();
            if (cached && now - cached.checkedAt < JOURNEY_CACHE_TTL) return cached.text;

            const progressUrl = `https://drgl.nl${journeyPath.replace(/\/$/, '')}/progress`;
            const html = await fetchDrglData(progressUrl);
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const text = doc.querySelector('.ott-btm-vjprogress')?.textContent?.trim() || '';

            journeyProgressCache.set(journeyPath, { text, checkedAt: now });
            return text;
        }

        async function getRemainingStopsCount(journeyPath, targetStopId) {
            if (!journeyPath || !targetStopId) return null;

            const [stops, progressText] = await Promise.all([
                fetchJourneyStops(journeyPath),
                fetchJourneyProgress(journeyPath)
            ]);

            if (!stops.length) return null;

            const targetIndex = stops.findIndex(stop => stop.stopId === targetStopId);
            if (targetIndex < 0) return null;

            const match = progressText.match(/tussen\s+(.+)\s+en\s+(.+)/i);
            const nextStopName = match ? normalizeStopName(match[2]) : '';
            if (!nextStopName) return null;

            const nextIndex = stops.findIndex(stop => {
                const stopName = normalizeStopName(stop.name);
                return stopName === nextStopName ||
                    stopName.includes(nextStopName) ||
                    nextStopName.includes(stopName);
            });

            if (nextIndex < 0) return null;
            if (targetIndex < nextIndex) return 0;

            return targetIndex - nextIndex + 1;
        }

        // Parse HTML naar departure objecten
        function parseDrglHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const departures = [];
            const now = new Date();

            doc.querySelectorAll('.list-group-item').forEach(row => {
                try {
                    const journeyPath = row.getAttribute('href') || '';
                    if (journeyPath && !journeyPath.startsWith('/journey/')) return;

                    // Tijd ophalen (bevat ook eventuele vertraging zoals "21:10 +11")
                    const timeEl = row.querySelector('.ott-departure-time');
                    const timeText = timeEl?.textContent?.trim() || '';

                    // Lijnnummer
                    const lineEl = row.querySelector('.ott-linecode');
                    const line = lineEl?.textContent?.trim() || '?';

                    // Bestemming
                    const destEl = row.querySelector('.ott-destination');
                    const destination = destEl?.textContent?.trim() || 'Onbekend';

                    // Vertraging uit tijdtekst halen (bijv. "21:10 +11" -> 11)
                    const delayMatch = timeText.match(/\+(\d+)/);
                    const delayMinutes = delayMatch ? parseInt(delayMatch[1]) : 0;

                    // Status (rijdend of gepland)
                    const isRealtime = timeEl?.classList.contains('ott-tripstatus-driving') || false;
                    const isCancelled = row.querySelector('.ott-departure-cancelled') !== null;

                    // Parse tijd naar Date object
                    // drgl.nl toont de GEPLANDE tijd, dus we moeten vertraging erbij optellen
                    let targetTime = null; // geplande tijd
                    let expectedTime = null; // werkelijke verwachte tijd (gepland + vertraging)

                    const timeParts = timeText.match(/(\d{1,2}):(\d{2})/);
                    if (timeParts) {
                        targetTime = new Date(now);
                        targetTime.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0, 0);

                        // Als tijd in het verleden ligt (meer dan 2 uur), is het morgen
                        if (targetTime < now - 2 * 60 * 60000) {
                            targetTime.setDate(targetTime.getDate() + 1);
                        }

                        // Werkelijke vertrektijd = geplande tijd + vertraging
                        expectedTime = new Date(targetTime.getTime() + delayMinutes * 60000);
                    }

                    if (!expectedTime) return;

                    // Filter: toon bussen die nog moeten vertrekken (met kleine marge)
                    const minutes = Math.floor((expectedTime - now) / 60000);
                    if (minutes < -1 || minutes > 120) return;

                    departures.push({
                        line,
                        destination,
                        expectedTime,
                        targetTime,
                        minutes,
                        delayMinutes,
                        isRealtime,
                        cancelled: isCancelled,
                        direction: getDirectionFromDestination(destination),
                        journeyPath
                    });
                } catch (e) {
                    console.warn('Failed to parse row:', e);
                }
            });

            return departures;
        }

        // Parse trein HTML naar departure objecten
        function parseTrainHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const departures = [];
            const now = new Date();

            doc.querySelectorAll('.list-group-item').forEach(row => {
                try {
                    // Tijd ophalen
                    const timeEl = row.querySelector('.ott-departure-time');
                    const timeText = timeEl?.textContent?.trim() || '';

                    // Treintype (Sprinter, Intercity, etc.)
                    const typeEl = row.querySelector('.ott-productcategory');
                    const typeText = typeEl?.textContent?.trim() || '';
                    const trainType = typeText.split('•')[0]?.trim() || 'Trein';

                    // Bestemming
                    const destEl = row.querySelector('.ott-destination');
                    const destination = destEl?.textContent?.trim() || 'Onbekend';

                    // Perron
                    const platformEl = row.querySelector('.ott-trainplatform');
                    const platform = platformEl?.textContent?.trim() || '';

                    // Vertraging
                    const delayMatch = timeText.match(/\+(\d+)/);
                    const delayMinutes = delayMatch ? parseInt(delayMatch[1]) : 0;

                    // Status
                    const isRealtime = timeEl?.classList.contains('ott-tripstatus-driving') || false;
                    const isCancelled = row.querySelector('.ott-departure-cancelled') !== null ||
                                       row.textContent.includes('Rijdt niet');

                    // Parse tijd
                    let targetTime = null;
                    let expectedTime = null;

                    const timeParts = timeText.match(/(\d{1,2}):(\d{2})/);
                    if (timeParts) {
                        targetTime = new Date(now);
                        targetTime.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0, 0);

                        if (targetTime < now - 2 * 60 * 60000) {
                            targetTime.setDate(targetTime.getDate() + 1);
                        }

                        expectedTime = new Date(targetTime.getTime() + delayMinutes * 60000);
                    }

                    if (!expectedTime) return;

                    const minutes = Math.floor((expectedTime - now) / 60000);
                    if (minutes < -1 || minutes > 120) return;

                    departures.push({
                        line: trainType,
                        destination,
                        platform,
                        expectedTime,
                        targetTime,
                        minutes,
                        delayMinutes,
                        isRealtime,
                        cancelled: isCancelled,
                        type: 'train'
                    });
                } catch (e) {
                    console.warn('Failed to parse train row:', e);
                }
            });

            return departures;
        }

        function getDirectionFromDestination(destination) {
            const dest = destination?.toLowerCase() || '';
            if (dest.includes('utrecht') || dest.includes('uithof') || dest.includes('wkz') ||
                dest.includes('science') || dest.includes('vaartsche') || dest.includes('p+r') ||
                dest.includes('bilthoven') || dest.includes('meernbrug')) {
                return 'utrecht';
            }
            return 'vleuten';
        }

        function formatTime(date) {
            if (!date) return '--:--';
            return date.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
        }

        function getTimeClass(minutes) {
            if (minutes <= 0) return 'now';
            if (minutes <= 5) return 'soon';
            return '';
        }

        async function loadDepartures() {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const content = document.getElementById('content');

            try {
                // Haal bus en trein data parallel op
                const [busHtml, trainHtml] = await Promise.all([
                    fetchDrglData(BUS_URL).catch(() => ''),
                    fetchDrglData(TRAIN_URL).catch(() => '')
                ]);

                const busDepartures = parseDrglHtml(busHtml);
                const trainDepartures = parseTrainHtml(trainHtml);

                console.log(`DRGL: ${busDepartures.length} bus departures, ${trainDepartures.length} train departures`);

                // Sort en filter bus duplicaten
                busDepartures.sort((a, b) => a.expectedTime - b.expectedTime);

                const uniqueBusDepartures = busDepartures.filter((dep, index, arr) => {
                    return !arr.slice(0, index).some(
                        prev => prev.line === dep.line &&
                               prev.destination === dep.destination &&
                               Math.abs(prev.minutes - dep.minutes) <= 1
                    );
                });

                const utrechtDepartures = uniqueBusDepartures.filter(d => d.direction === 'utrecht').slice(0, 5);
                const vleutenDepartures = uniqueBusDepartures.filter(d => d.direction === 'vleuten').slice(0, 5);

                // Sort treinen
                trainDepartures.sort((a, b) => a.expectedTime - b.expectedTime);
                const trainList = trainDepartures.slice(0, 6);

                renderDepartures(utrechtDepartures, vleutenDepartures, trainList);

                statusDot.classList.remove('error');
                const timeStr = new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                statusText.textContent = `Bijgewerkt ${timeStr}`;

            } catch (error) {
                console.error('Error loading departures:', error);
                statusDot.classList.add('error');
                statusText.textContent = 'Verbinding mislukt';
                content.innerHTML = `
                    <div class="error-message">
                        <p>Kon vertrektijden niet laden.</p>
                        <p style="margin-top: 0.5rem; font-size: 0.85rem;">Probeer het opnieuw of controleer je internetverbinding.</p>
                    </div>
                `;
            }

        }

        function renderDepartures(utrechtDepartures, vleutenDepartures, trainDepartures) {
            const content = document.getElementById('content');

            let html = '';

            // Utrecht direction (bus)
            html += renderSection('utrecht', 'Bus naar Utrecht', utrechtDepartures, 'bus');

            // Vleuten direction (bus)
            html += renderSection('vleuten', 'Bus naar Vleuten', vleutenDepartures, 'bus');

            // Treinen vanaf station Vleuten
            html += renderSection('train', 'Trein vanaf Vleuten', trainDepartures, 'train');

            content.innerHTML = html;

            // Add click handlers for expanding sections
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const section = header.closest('.departures-section');
                    section.classList.toggle('expanded');
                });
            });

            // Live positie badges en kaart-interactie
            const busDepartures = [...utrechtDepartures, ...vleutenDepartures];
            updateLiveIndicators(busDepartures);

            document.querySelectorAll('.departure-card[data-journey]').forEach(card => {
                card.addEventListener('click', () => {
                    if (card.dataset.live !== 'true') return;
                    openLiveMap(
                        card.dataset.journey,
                        card.dataset.line,
                        card.dataset.destination,
                        card.dataset.realtime === 'true'
                    );
                });
            });
        }

        function renderSection(id, title, departures, type) {
            const first = departures[0];
            const hasMore = departures.length > 0;

            let timeDisplay = '--';
            let timeClass = '';
            let timeUnit = '';
            let preview = 'Geen vertrektijden';

            if (first && !first.cancelled) {
                if (first.minutes <= 0) {
                    timeDisplay = 'Nu';
                    timeClass = 'now';
                } else {
                    timeDisplay = first.minutes.toString();
                    timeUnit = 'min';
                    if (first.minutes <= 5) timeClass = 'soon';
                }
                preview = `<span class="line">${first.line}</span> naar ${first.destination}`;
            } else if (first && first.cancelled) {
                preview = `<span class="line">${first.line}</span> vervalt`;
            }

            const iconColor = type === 'train' ? '#1c1c1f' : 'white';
            const busIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2"><rect x="3" y="3" width="18" height="14" rx="2"/><path d="M3 9h18M7 17v2M17 17v2"/></svg>`;
            const trainIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2"><path d="M4 15l4-8h8l4 8M4 15h16M6 19l2-4M18 19l-2-4M9 11h6"/></svg>`;

            return `
                <div class="departures-section" id="section-${id}">
                    <div class="section-header">
                        <div class="direction-icon ${type === 'train' ? 'train' : ''}">
                            ${type === 'train' ? trainIcon : busIcon}
                        </div>
                        <div class="header-info">
                            <div class="direction-title">${title}</div>
                            <div class="next-departure-preview">${preview}</div>
                        </div>
                        <div class="header-time">
                            <div class="header-time-value ${timeClass}">${timeDisplay}</div>
                            ${timeUnit ? `<div class="header-time-unit">${timeUnit}</div>` : ''}
                        </div>
                        ${hasMore ? `
                            <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M6 9l6 6 6-6"/>
                            </svg>
                        ` : '<div style="width: 20px"></div>'}
                    </div>
                    ${hasMore ? `
                        <div class="departure-list">
                            <div class="departure-list-inner">
                                ${departures.map(dep => type === 'train' ? renderTrainCard(dep) : renderDepartureCard(dep)).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function getStatusInfo(departure) {
            if (departure.cancelled) {
                return { class: 'major-delay', label: 'Vervalt' };
            }
            if (!departure.isRealtime) {
                return { class: 'on-time', label: 'Gepland' };
            }
            if (departure.delayMinutes <= 1) {
                return { class: 'on-time', label: 'Op tijd' };
            }
            if (departure.delayMinutes <= 5) {
                return { class: 'slight-delay', label: `+${departure.delayMinutes} min` };
            }
            return { class: 'major-delay', label: `+${departure.delayMinutes} min` };
        }

        function renderDepartureCard(departure) {
            const timeClass = departure.cancelled ? '' : getTimeClass(departure.minutes);
            const statusInfo = getStatusInfo(departure);

            let timeDisplay;
            if (departure.cancelled) {
                timeDisplay = '--';
            } else if (departure.minutes <= 0) {
                timeDisplay = 'Nu';
            } else {
                timeDisplay = departure.minutes.toString();
            }

            const journeyAttr = departure.journeyPath
                ? `data-journey="${departure.journeyPath}" data-live="false" data-realtime="${departure.isRealtime ? 'true' : 'false'}"`
                : '';

            return `
                <div class="departure-card ${departure.cancelled ? 'cancelled' : ''}" ${journeyAttr} data-line="${departure.line}" data-destination="${departure.destination}">
                    <div class="line-badge">${departure.line}</div>
                    <div class="departure-info">
                        <div class="destination">${departure.destination}</div>
                        <div class="status-indicator">
                            ${departure.journeyPath ? '<span class="live-indicator" hidden>Live</span>' : ''}
                            <span class="status-dot-small ${statusInfo.class}"></span>
                            <span class="status-label ${statusInfo.class}">${statusInfo.label}</span>
                        </div>
                    </div>
                    <div class="departure-time">
                        ${departure.cancelled ?
                            '<div class="cancelled-label">Vervalt</div>' :
                            `<div class="time-value ${timeClass}">${timeDisplay}</div>
                             ${departure.minutes > 0 ? '<div class="time-unit">min</div>' : ''}`
                        }
                        <div class="actual-time">${formatTime(departure.expectedTime)}</div>
                    </div>
                </div>
            `;
        }

        function renderTrainCard(departure) {
            const timeClass = departure.cancelled ? '' : getTimeClass(departure.minutes);
            const statusInfo = getStatusInfo(departure);

            let timeDisplay;
            if (departure.cancelled) {
                timeDisplay = '--';
            } else if (departure.minutes <= 0) {
                timeDisplay = 'Nu';
            } else {
                timeDisplay = departure.minutes.toString();
            }

            return `
                <div class="departure-card ${departure.cancelled ? 'cancelled' : ''}">
                    <div class="line-badge train">${departure.line}</div>
                    <div class="departure-info">
                        <div class="destination">${departure.destination}</div>
                        <div class="status-indicator">
                            ${departure.platform ? `<span class="platform-badge">Spoor ${departure.platform}</span>` : ''}
                            <span class="status-dot-small ${statusInfo.class}"></span>
                            <span class="status-label ${statusInfo.class}">${statusInfo.label}</span>
                        </div>
                    </div>
                    <div class="departure-time">
                        ${departure.cancelled ?
                            '<div class="cancelled-label">Vervalt</div>' :
                            `<div class="time-value ${timeClass}">${timeDisplay}</div>
                             ${departure.minutes > 0 ? '<div class="time-unit">min</div>' : ''}`
                        }
                        <div class="actual-time">${formatTime(departure.expectedTime)}</div>
                    </div>
                </div>
            `;
        }

        function buildPositionUrl(journeyPath) {
            if (!journeyPath) return '';
            const basePath = journeyPath.endsWith('/') ? journeyPath.slice(0, -1) : journeyPath;
            return `https://drgl.nl${basePath}/position`;
        }

        function buildPolylineUrl(journeyPath) {
            if (!journeyPath) return '';
            const basePath = journeyPath.endsWith('/') ? journeyPath.slice(0, -1) : journeyPath;
            return `https://drgl.nl${basePath}/polyline`;
        }

        function decodePolyline(encoded) {
            let index = 0;
            let lat = 0;
            let lon = 0;
            const coords = [];

            while (index < encoded.length) {
                let result = 0;
                let shift = 0;
                let byte;

                do {
                    byte = encoded.charCodeAt(index++) - 63;
                    result |= (byte & 0x1f) << shift;
                    shift += 5;
                } while (byte >= 0x20);

                const deltaLat = (result & 1) ? ~(result >> 1) : (result >> 1);
                lat += deltaLat;

                result = 0;
                shift = 0;
                do {
                    byte = encoded.charCodeAt(index++) - 63;
                    result |= (byte & 0x1f) << shift;
                    shift += 5;
                } while (byte >= 0x20);

                const deltaLon = (result & 1) ? ~(result >> 1) : (result >> 1);
                lon += deltaLon;

                coords.push([lat / 1e5, lon / 1e5]);
            }

            return coords;
        }

        function findClosestIndex(coords, target) {
            let bestIndex = 0;
            let bestDist = Infinity;
            const [tLat, tLon] = target;

            coords.forEach(([lat, lon], index) => {
                const dLat = lat - tLat;
                const dLon = lon - tLon;
                const dist = dLat * dLat + dLon * dLon;
                if (dist < bestDist) {
                    bestDist = dist;
                    bestIndex = index;
                }
            });

            return bestIndex;
        }

        function clearRouteLayers() {
            if (liveRouteLine) {
                liveRouteLine.remove();
                liveRouteLine = null;
            }
            if (liveRemainingLine) {
                liveRemainingLine.remove();
                liveRemainingLine = null;
            }
            if (liveStopMarker) {
                liveStopMarker.remove();
                liveStopMarker = null;
            }
            liveRouteCoords = null;
        }

        async function loadJourneyRoute() {
            if (!liveJourneyPath) return;
            const polylineUrl = buildPolylineUrl(liveJourneyPath);
            if (!polylineUrl) return;

            try {
                const data = await fetchDrglJson(polylineUrl);
                const polylines = Array.isArray(data?.polyLines) ? data.polyLines : [];
                if (!polylines.length) return;

                const coords = polylines.flatMap(line => decodePolyline(line));
                if (!coords.length) return;

                liveRouteCoords = coords;

                if (liveRouteLine) {
                    liveRouteLine.setLatLngs(coords);
                } else {
                    liveRouteLine = L.polyline(coords, {
                        color: '#94a3b8',
                        weight: 4,
                        opacity: 0.6
                    }).addTo(liveMap);
                }

                const stopCoords = BUS_STOP_COORDS[BUS_STOP_AREA];
                if (stopCoords) {
                    const stopLatLng = [stopCoords.lat, stopCoords.lon];
                    if (liveStopMarker) {
                        liveStopMarker.setLatLng(stopLatLng);
                    } else {
                        liveStopMarker = L.circleMarker(stopLatLng, {
                            radius: 6,
                            color: '#1d4ed8',
                            fillColor: '#3b82f6',
                            fillOpacity: 0.9
                        }).addTo(liveMap);
                    }
                }
            } catch (e) {
                // ignore route errors
            }
        }

        async function fetchLivePositionStatus(journeyPath) {
            const cached = positionCache.get(journeyPath);
            const now = Date.now();
            if (cached && now - cached.checkedAt < POSITION_CACHE_TTL) return cached;

            const positionUrl = buildPositionUrl(journeyPath);
            if (!positionUrl) throw new Error('Missing journey path');

            const data = await fetchDrglJson(positionUrl);
            const hasPosition = Array.isArray(data?.features) && data.features.length > 0;
            const result = { hasPosition, checkedAt: now };
            positionCache.set(journeyPath, result);
            return result;
        }

        function updateLiveIndicators(departures) {
            const tasks = departures
                .filter(dep => dep.journeyPath)
                .slice(0, 10)
                .map(async dep => {
                    try {
                        const status = await fetchLivePositionStatus(dep.journeyPath);
                        if (!status.hasPosition) return;
                        const card = document.querySelector(`.departure-card[data-journey="${CSS.escape(dep.journeyPath)}"]`);
                        if (!card) return;
                        card.dataset.live = 'true';
                        card.classList.add('live-available');
                        const badge = card.querySelector('.live-indicator');
                        if (badge) badge.hidden = false;
                    } catch (e) {
                        // ignore per-departure errors
                    }
                });

            Promise.allSettled(tasks);
        }

        function ensureMap() {
            if (liveMap) return;
            liveMap = L.map('liveMap', { zoomControl: true });
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 19,
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
            }).addTo(liveMap);
        }

        function startLiveMapTimer() {
            clearInterval(liveMapTimer);
            liveMapTimer = setInterval(refreshLiveMap, 10000);
        }

        async function openLiveMap(journeyPath, line, destination, isRealtime) {
            const modal = document.getElementById('mapModal');
            const meta = document.getElementById('mapMeta');
            modal.classList.add('visible');
            modal.setAttribute('aria-hidden', 'false');
            meta.textContent = 'Laden...';
            const isNewJourney = liveJourneyPath && liveJourneyPath !== journeyPath;
            if (isNewJourney) {
                clearRouteLayers();
            }
            liveJourneyPath = journeyPath;
            liveJourneyLabel = `${line} naar ${destination}`;
            liveJourneyRealtime = Boolean(isRealtime);

            ensureMap();
            setTimeout(() => liveMap.invalidateSize(), 100);

            await loadJourneyRoute();
            await refreshLiveMap();
            startLiveMapTimer();
        }

        function closeMapModal() {
            const modal = document.getElementById('mapModal');
            modal.classList.remove('visible');
            modal.setAttribute('aria-hidden', 'true');
            clearInterval(liveMapTimer);
            liveMapTimer = null;
            liveJourneyPath = null;
            liveJourneyLabel = null;
            liveJourneyRealtime = false;
            const badge = document.getElementById('mapStopsBadge');
            if (badge) {
                badge.hidden = true;
                badge.textContent = '';
            }
            clearRouteLayers();
        }

        function updateRemainingRoute(currentLat, currentLon) {
            if (!liveRouteCoords || !liveRouteCoords.length) return false;

            const currentIndex = findClosestIndex(liveRouteCoords, [currentLat, currentLon]);
            let remainingCoords = liveRouteCoords.slice(currentIndex);
            let stopPassed = false;

            const stopCoords = BUS_STOP_COORDS[BUS_STOP_AREA];
            if (stopCoords) {
                const stopIndex = findClosestIndex(liveRouteCoords, [stopCoords.lat, stopCoords.lon]);
                if (stopIndex >= currentIndex) {
                    remainingCoords = liveRouteCoords.slice(currentIndex, stopIndex + 1);
                } else {
                    stopPassed = true;
                }
            }

            if (liveRemainingLine) {
                liveRemainingLine.setLatLngs(remainingCoords);
            } else {
                liveRemainingLine = L.polyline(remainingCoords, {
                    color: '#3b82f6',
                    weight: 5,
                    opacity: 0.9
                }).addTo(liveMap);
            }

            return stopPassed;
        }

        async function refreshLiveMap() {
            const meta = document.getElementById('mapMeta');
            const badge = document.getElementById('mapStopsBadge');
            const mapSheet = document.querySelector('.map-sheet');
            if (!liveJourneyPath) return;
            try {
                const positionUrl = buildPositionUrl(liveJourneyPath);
                const data = await fetchDrglJson(positionUrl);
                const feature = data?.features?.[0];
                const coords = feature?.geometry?.coordinates;
                liveJourneyRealtime = Boolean(feature);
                if (mapSheet) {
                    mapSheet.classList.toggle('realtime-off', !liveJourneyRealtime);
                }
                if (!Array.isArray(coords) || coords.length < 2) {
                    meta.textContent = 'Geen live positie beschikbaar.';
                    if (badge && badge.textContent) {
                        badge.hidden = false;
                    }
                    return;
                }
                const [lon, lat] = coords;
                if (liveMarker) {
                    liveMarker.setLatLng([lat, lon]);
                } else {
                    if (!liveMarkerIcon) {
                        liveMarkerIcon = L.divIcon({
                            className: 'live-marker',
                            html: '<span class="live-marker-core"></span>',
                            iconSize: [22, 22],
                            iconAnchor: [11, 11]
                        });
                    }
                    liveMarker = L.marker([lat, lon], { icon: liveMarkerIcon }).addTo(liveMap);
                }
                liveMap.setView([lat, lon], 15);
                const stopPassed = updateRemainingRoute(lat, lon);
                let remainingStops = null;
                if (liveJourneyRealtime) {
                    try {
                        remainingStops = await getRemainingStopsCount(liveJourneyPath, BUS_STOP_AREA);
                    } catch (e) {
                        remainingStops = null;
                    }
                }
                const timeStr = new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                if (stopPassed && liveJourneyRealtime) {
                    meta.textContent = `${liveJourneyLabel} · halte al gepasseerd · bijgewerkt ${timeStr}`;
                    if (badge) {
                        badge.hidden = false;
                        badge.textContent = 'Halte gepasseerd';
                    }
                } else if (remainingStops !== null && liveJourneyRealtime) {
                    const stopLabel = remainingStops === 0 ? 'Laatste halte' : `Nog ${remainingStops} haltes`;
                    meta.textContent = `${liveJourneyLabel} · ${stopLabel} · bijgewerkt ${timeStr}`;
                    if (badge) {
                        badge.hidden = false;
                        badge.textContent = stopLabel;
                    }
                } else {
                    meta.textContent = `${liveJourneyLabel} · bijgewerkt ${timeStr}`;
                    if (badge) {
                        badge.hidden = false;
                    }
                }
            } catch (e) {
                meta.textContent = 'Kon live positie niet laden.';
                if (badge && badge.textContent) {
                    badge.hidden = false;
                }
            }
        }

        // Refresh knop handler
        function handleRefreshClick() {
            const statusText = document.getElementById('statusText');
            const refreshBtn = document.getElementById('refreshBtn');

            statusText.textContent = 'Verversen...';
            refreshBtn.classList.add('spinning');

            const minSpinTime = new Promise(resolve => setTimeout(resolve, 500));

            Promise.all([loadDepartures(), minSpinTime]).finally(() => {
                refreshBtn.classList.remove('spinning');
            });
        }

        // Initial load
        loadDepartures();

        // Auto-refresh
        refreshTimer = setInterval(loadDepartures, REFRESH_INTERVAL);

        // Visibility API - pause refresh when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                clearInterval(refreshTimer);
                clearInterval(liveMapTimer);
            } else {
                loadDepartures();
                refreshTimer = setInterval(loadDepartures, REFRESH_INTERVAL);
                if (liveJourneyPath && document.getElementById('mapModal')?.classList.contains('visible')) {
                    refreshLiveMap();
                    startLiveMapTimer();
                }
            }
        });
    </script>
</body>
</html>
