<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OV Tijden De Meern & Vleuten</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>OV Tijden</h1>
        </header>

        <div class="status-bar">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Verbonden</span>
        </div>

        <div id="content">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Laden...</p>
            </div>
        </div>

        <footer>
            <a href="https://drgl.nl" target="_blank">drgl.nl</a>
        </footer>
    </div>

    <script>
        // Bus halte
        const BUS_STOP_AREA = 'NL:S:51200123';
        const BUS_URL = `https://drgl.nl/stop/${BUS_STOP_AREA}/departurespanel`;

        // Trein station Vleuten
        const TRAIN_STOP_AREA = 'NL:S:vtn';
        const TRAIN_URL = `https://drgl.nl/stop/${TRAIN_STOP_AREA}/traindeparturespanel`;

        const REFRESH_INTERVAL = 15000;

        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?'
        ];
        const FETCH_TIMEOUT = 5000; // 5 seconden timeout per proxy
        let refreshTimer;

        // Fetch HTML van drgl.nl via CORS proxy (parallel racing)
        async function fetchDrglData(url) {
            const fetchWithTimeout = async (proxyUrl) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

                try {
                    const response = await fetch(proxyUrl, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error('Response not ok');
                    return response.text();
                } catch (e) {
                    clearTimeout(timeoutId);
                    throw e;
                }
            };

            const proxyUrls = CORS_PROXIES.map(proxy => proxy + encodeURIComponent(url));

            try {
                // Race beide proxies parallel - de snelste wint
                return await Promise.any(proxyUrls.map(fetchWithTimeout));
            } catch (e) {
                throw new Error('All proxies failed');
            }
        }

        // Parse HTML naar departure objecten
        function parseDrglHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const departures = [];
            const now = new Date();

            doc.querySelectorAll('.list-group-item').forEach(row => {
                try {
                    // Tijd ophalen (bevat ook eventuele vertraging zoals "21:10 +11")
                    const timeEl = row.querySelector('.ott-departure-time');
                    const timeText = timeEl?.textContent?.trim() || '';

                    // Lijnnummer
                    const lineEl = row.querySelector('.ott-linecode');
                    const line = lineEl?.textContent?.trim() || '?';

                    // Bestemming
                    const destEl = row.querySelector('.ott-destination');
                    const destination = destEl?.textContent?.trim() || 'Onbekend';

                    // Vertraging uit tijdtekst halen (bijv. "21:10 +11" -> 11)
                    const delayMatch = timeText.match(/\+(\d+)/);
                    const delayMinutes = delayMatch ? parseInt(delayMatch[1]) : 0;

                    // Status (rijdend of gepland)
                    const isRealtime = timeEl?.classList.contains('ott-tripstatus-driving') || false;
                    const isCancelled = row.querySelector('.ott-departure-cancelled') !== null;

                    // Parse tijd naar Date object
                    // drgl.nl toont de GEPLANDE tijd, dus we moeten vertraging erbij optellen
                    let targetTime = null; // geplande tijd
                    let expectedTime = null; // werkelijke verwachte tijd (gepland + vertraging)

                    const timeParts = timeText.match(/(\d{1,2}):(\d{2})/);
                    if (timeParts) {
                        targetTime = new Date(now);
                        targetTime.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0, 0);

                        // Als tijd in het verleden ligt (meer dan 2 uur), is het morgen
                        if (targetTime < now - 2 * 60 * 60000) {
                            targetTime.setDate(targetTime.getDate() + 1);
                        }

                        // Werkelijke vertrektijd = geplande tijd + vertraging
                        expectedTime = new Date(targetTime.getTime() + delayMinutes * 60000);
                    }

                    if (!expectedTime) return;

                    // Filter: toon bussen die nog moeten vertrekken (met kleine marge)
                    const minutes = Math.floor((expectedTime - now) / 60000);
                    if (minutes < -1 || minutes > 120) return;

                    departures.push({
                        line,
                        destination,
                        expectedTime,
                        targetTime,
                        minutes,
                        delayMinutes,
                        isRealtime,
                        cancelled: isCancelled,
                        direction: getDirectionFromDestination(destination)
                    });
                } catch (e) {
                    console.warn('Failed to parse row:', e);
                }
            });

            return departures;
        }

        // Parse trein HTML naar departure objecten
        function parseTrainHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const departures = [];
            const now = new Date();

            doc.querySelectorAll('.list-group-item').forEach(row => {
                try {
                    // Tijd ophalen
                    const timeEl = row.querySelector('.ott-departure-time');
                    const timeText = timeEl?.textContent?.trim() || '';

                    // Treintype (Sprinter, Intercity, etc.)
                    const typeEl = row.querySelector('.ott-productcategory');
                    const typeText = typeEl?.textContent?.trim() || '';
                    const trainType = typeText.split('â€¢')[0]?.trim() || 'Trein';

                    // Bestemming
                    const destEl = row.querySelector('.ott-destination');
                    const destination = destEl?.textContent?.trim() || 'Onbekend';

                    // Perron
                    const platformEl = row.querySelector('.ott-trainplatform');
                    const platform = platformEl?.textContent?.trim() || '';

                    // Vertraging
                    const delayMatch = timeText.match(/\+(\d+)/);
                    const delayMinutes = delayMatch ? parseInt(delayMatch[1]) : 0;

                    // Status
                    const isRealtime = timeEl?.classList.contains('ott-tripstatus-driving') || false;
                    const isCancelled = row.querySelector('.ott-departure-cancelled') !== null ||
                                       row.textContent.includes('Rijdt niet');

                    // Parse tijd
                    let targetTime = null;
                    let expectedTime = null;

                    const timeParts = timeText.match(/(\d{1,2}):(\d{2})/);
                    if (timeParts) {
                        targetTime = new Date(now);
                        targetTime.setHours(parseInt(timeParts[1]), parseInt(timeParts[2]), 0, 0);

                        if (targetTime < now - 2 * 60 * 60000) {
                            targetTime.setDate(targetTime.getDate() + 1);
                        }

                        expectedTime = new Date(targetTime.getTime() + delayMinutes * 60000);
                    }

                    if (!expectedTime) return;

                    const minutes = Math.floor((expectedTime - now) / 60000);
                    if (minutes < -1 || minutes > 120) return;

                    departures.push({
                        line: trainType,
                        destination,
                        platform,
                        expectedTime,
                        targetTime,
                        minutes,
                        delayMinutes,
                        isRealtime,
                        cancelled: isCancelled,
                        type: 'train'
                    });
                } catch (e) {
                    console.warn('Failed to parse train row:', e);
                }
            });

            return departures;
        }

        function getDirectionFromDestination(destination) {
            const dest = destination?.toLowerCase() || '';
            if (dest.includes('utrecht') || dest.includes('uithof') || dest.includes('wkz') ||
                dest.includes('science') || dest.includes('vaartsche') || dest.includes('p+r') ||
                dest.includes('bilthoven') || dest.includes('meernbrug')) {
                return 'utrecht';
            }
            return 'vleuten';
        }

        function formatTime(date) {
            if (!date) return '--:--';
            return date.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
        }

        function getTimeClass(minutes) {
            if (minutes <= 0) return 'now';
            if (minutes <= 5) return 'soon';
            return '';
        }

        async function loadDepartures() {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const content = document.getElementById('content');

            try {
                // Haal bus en trein data parallel op
                const [busHtml, trainHtml] = await Promise.all([
                    fetchDrglData(BUS_URL).catch(() => ''),
                    fetchDrglData(TRAIN_URL).catch(() => '')
                ]);

                const busDepartures = parseDrglHtml(busHtml);
                const trainDepartures = parseTrainHtml(trainHtml);

                console.log(`DRGL: ${busDepartures.length} bus departures, ${trainDepartures.length} train departures`);

                // Sort en filter bus duplicaten
                busDepartures.sort((a, b) => a.expectedTime - b.expectedTime);

                const uniqueBusDepartures = busDepartures.filter((dep, index, arr) => {
                    return !arr.slice(0, index).some(
                        prev => prev.line === dep.line &&
                               prev.destination === dep.destination &&
                               Math.abs(prev.minutes - dep.minutes) <= 1
                    );
                });

                const utrechtDepartures = uniqueBusDepartures.filter(d => d.direction === 'utrecht').slice(0, 5);
                const vleutenDepartures = uniqueBusDepartures.filter(d => d.direction === 'vleuten').slice(0, 5);

                // Sort treinen
                trainDepartures.sort((a, b) => a.expectedTime - b.expectedTime);
                const trainList = trainDepartures.slice(0, 6);

                renderDepartures(utrechtDepartures, vleutenDepartures, trainList);

                statusDot.classList.remove('error');
                const timeStr = new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                statusText.textContent = `Bijgewerkt ${timeStr}`;

            } catch (error) {
                console.error('Error loading departures:', error);
                statusDot.classList.add('error');
                statusText.textContent = 'Verbinding mislukt';
                content.innerHTML = `
                    <div class="error-message">
                        <p>Kon vertrektijden niet laden.</p>
                        <p style="margin-top: 0.5rem; font-size: 0.85rem;">Probeer het opnieuw of controleer je internetverbinding.</p>
                    </div>
                `;
            }

        }

        function renderDepartures(utrechtDepartures, vleutenDepartures, trainDepartures) {
            const content = document.getElementById('content');

            let html = '';

            // Utrecht direction (bus)
            html += renderSection('utrecht', 'Bus naar Utrecht', utrechtDepartures, 'bus');

            // Vleuten direction (bus)
            html += renderSection('vleuten', 'Bus naar Vleuten', vleutenDepartures, 'bus');

            // Treinen vanaf station Vleuten
            html += renderSection('train', 'Trein vanaf Vleuten', trainDepartures, 'train');

            content.innerHTML = html;

            // Add click handlers for expanding sections
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const section = header.closest('.departures-section');
                    section.classList.toggle('expanded');
                });
            });
        }

        function renderSection(id, title, departures, type) {
            const first = departures[0];
            const hasMore = departures.length > 0;

            let timeDisplay = '--';
            let timeClass = '';
            let timeUnit = '';
            let preview = 'Geen vertrektijden';

            if (first && !first.cancelled) {
                if (first.minutes <= 0) {
                    timeDisplay = 'Nu';
                    timeClass = 'now';
                } else {
                    timeDisplay = first.minutes.toString();
                    timeUnit = 'min';
                    if (first.minutes <= 5) timeClass = 'soon';
                }
                preview = `<span class="line">${first.line}</span> naar ${first.destination}`;
            } else if (first && first.cancelled) {
                preview = `<span class="line">${first.line}</span> vervalt`;
            }

            const iconColor = type === 'train' ? '#1c1c1f' : 'white';
            const busIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2"><rect x="3" y="3" width="18" height="14" rx="2"/><path d="M3 9h18M7 17v2M17 17v2"/></svg>`;
            const trainIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2"><path d="M4 15l4-8h8l4 8M4 15h16M6 19l2-4M18 19l-2-4M9 11h6"/></svg>`;

            return `
                <div class="departures-section" id="section-${id}">
                    <div class="section-header">
                        <div class="direction-icon ${type === 'train' ? 'train' : ''}">
                            ${type === 'train' ? trainIcon : busIcon}
                        </div>
                        <div class="header-info">
                            <div class="direction-title">${title}</div>
                            <div class="next-departure-preview">${preview}</div>
                        </div>
                        <div class="header-time">
                            <div class="header-time-value ${timeClass}">${timeDisplay}</div>
                            ${timeUnit ? `<div class="header-time-unit">${timeUnit}</div>` : ''}
                        </div>
                        ${hasMore ? `
                            <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M6 9l6 6 6-6"/>
                            </svg>
                        ` : '<div style="width: 20px"></div>'}
                    </div>
                    ${hasMore ? `
                        <div class="departure-list">
                            <div class="departure-list-inner">
                                ${departures.map(dep => type === 'train' ? renderTrainCard(dep) : renderDepartureCard(dep)).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function getStatusInfo(departure) {
            if (departure.cancelled) {
                return { class: 'major-delay', label: 'Vervalt' };
            }
            if (!departure.isRealtime) {
                return { class: 'on-time', label: 'Gepland' };
            }
            if (departure.delayMinutes <= 1) {
                return { class: 'on-time', label: 'Op tijd' };
            }
            if (departure.delayMinutes <= 5) {
                return { class: 'slight-delay', label: `+${departure.delayMinutes} min` };
            }
            return { class: 'major-delay', label: `+${departure.delayMinutes} min` };
        }

        function renderDepartureCard(departure) {
            const timeClass = departure.cancelled ? '' : getTimeClass(departure.minutes);
            const statusInfo = getStatusInfo(departure);

            let timeDisplay;
            if (departure.cancelled) {
                timeDisplay = '--';
            } else if (departure.minutes <= 0) {
                timeDisplay = 'Nu';
            } else {
                timeDisplay = departure.minutes.toString();
            }

            return `
                <div class="departure-card ${departure.cancelled ? 'cancelled' : ''}">
                    <div class="line-badge">${departure.line}</div>
                    <div class="departure-info">
                        <div class="destination">${departure.destination}</div>
                        <div class="status-indicator">
                            <span class="status-dot-small ${statusInfo.class}"></span>
                            <span class="status-label ${statusInfo.class}">${statusInfo.label}</span>
                        </div>
                    </div>
                    <div class="departure-time">
                        ${departure.cancelled ?
                            '<div class="cancelled-label">Vervalt</div>' :
                            `<div class="time-value ${timeClass}">${timeDisplay}</div>
                             ${departure.minutes > 0 ? '<div class="time-unit">min</div>' : ''}`
                        }
                        <div class="actual-time">${formatTime(departure.expectedTime)}</div>
                    </div>
                </div>
            `;
        }

        function renderTrainCard(departure) {
            const timeClass = departure.cancelled ? '' : getTimeClass(departure.minutes);
            const statusInfo = getStatusInfo(departure);

            let timeDisplay;
            if (departure.cancelled) {
                timeDisplay = '--';
            } else if (departure.minutes <= 0) {
                timeDisplay = 'Nu';
            } else {
                timeDisplay = departure.minutes.toString();
            }

            return `
                <div class="departure-card ${departure.cancelled ? 'cancelled' : ''}">
                    <div class="line-badge train">${departure.line}</div>
                    <div class="departure-info">
                        <div class="destination">${departure.destination}</div>
                        <div class="status-indicator">
                            ${departure.platform ? `<span class="platform-badge">Spoor ${departure.platform}</span>` : ''}
                            <span class="status-dot-small ${statusInfo.class}"></span>
                            <span class="status-label ${statusInfo.class}">${statusInfo.label}</span>
                        </div>
                    </div>
                    <div class="departure-time">
                        ${departure.cancelled ?
                            '<div class="cancelled-label">Vervalt</div>' :
                            `<div class="time-value ${timeClass}">${timeDisplay}</div>
                             ${departure.minutes > 0 ? '<div class="time-unit">min</div>' : ''}`
                        }
                        <div class="actual-time">${formatTime(departure.expectedTime)}</div>
                    </div>
                </div>
            `;
        }

        // Pull-to-refresh voor mobiel
        let touchStartY = 0;
        let touchCurrentY = 0;
        let isPulling = false;
        const pullThreshold = 80;

        document.addEventListener('touchstart', (e) => {
            if (window.scrollY === 0) {
                touchStartY = e.touches[0].clientY;
                isPulling = true;
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (!isPulling) return;
            touchCurrentY = e.touches[0].clientY;
            const pullDistance = touchCurrentY - touchStartY;

            if (pullDistance > 0 && window.scrollY === 0) {
                const statusText = document.getElementById('statusText');
                if (pullDistance > pullThreshold) {
                    statusText.textContent = 'Laat los om te verversen';
                } else {
                    statusText.textContent = 'Trek omlaag om te verversen';
                }
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            if (!isPulling) return;
            const pullDistance = touchCurrentY - touchStartY;

            if (pullDistance > pullThreshold && window.scrollY === 0) {
                const statusText = document.getElementById('statusText');
                statusText.textContent = 'Verversen...';
                loadDepartures();
            }

            isPulling = false;
            touchStartY = 0;
            touchCurrentY = 0;
        }, { passive: true });

        // Initial load
        loadDepartures();

        // Auto-refresh
        refreshTimer = setInterval(loadDepartures, REFRESH_INTERVAL);

        // Visibility API - pause refresh when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                clearInterval(refreshTimer);
            } else {
                loadDepartures();
                refreshTimer = setInterval(loadDepartures, REFRESH_INTERVAL);
            }
        });
    </script>
</body>
</html>